<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Patterns in Mathematics - CNN Pattern Recognition (4 Shapes)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
    <style>
      :root {
        --primary-color: #4a90e2;
        --primary-color-dark: #357abd;
        --success-color: #28a745;
        --error-color: #dc3545;
        --background-color: #f0f4fa;
        --text-color: #222;
        --shadow-light: rgba(74, 144, 226, 0.25);
        --shadow-strong: rgba(74, 144, 226, 0.45);
        --font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        --transition-speed: 0.3s;
      }
      * {
        box-sizing: border-box;
      }
      body {
        font-family: var(--font-family);
        margin: 0;
        padding: 20px;
        background: var(--background-color);
        color: var(--text-color);
        line-height: 1.7;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
      }
      header {
        background: linear-gradient(
          135deg,
          var(--primary-color),
          var(--primary-color-dark)
        );
        color: white;
        padding: 2.5rem;
        border-radius: 20px;
        text-align: center;
        box-shadow: 0 20px 40px var(--shadow-light);
        margin-bottom: 3rem;
      }
      h1 {
        margin: 0 0 1rem 0;
        font-size: 2.8rem;
        font-weight: 900;
      }
      .subtitle {
        font-size: 1.2rem;
        opacity: 0.95;
        margin: 0;
      }
      .cnn-section {
        background: white;
        padding: 3rem;
        border-radius: 25px;
        box-shadow: 0 15px 40px var(--shadow-light);
        margin: 2rem 0;
      }
      .cnn-title {
        color: var(--primary-color-dark);
        font-size: 2.2rem;
        border-bottom: 5px solid var(--primary-color);
        padding-bottom: 1rem;
        margin-bottom: 2rem;
      }
      .learning-content {
        background: linear-gradient(135deg, #f8fcff 0%, #e8f4ff 100%);
        padding: 2rem;
        border-radius: 20px;
        border-left: 8px solid var(--primary-color);
        margin-bottom: 2rem;
        font-size: 1.15rem;
      }
      #canvas {
        border: 3px solid var(--primary-color);
        border-radius: 15px;
        cursor: crosshair;
        background: #f8f9fa;
        display: block;
        margin: 0 auto;
      }
      .canvas-container {
        text-align: center;
        margin: 2rem 0;
      }
      .model-controls {
        display: flex;
        gap: 1rem;
        justify-content: center;
        flex-wrap: wrap;
        margin: 2rem 0;
      }
      button {
        background: linear-gradient(
          135deg,
          var(--primary-color),
          var(--primary-color-dark)
        );
        color: white;
        border: none;
        padding: 15px 30px;
        border-radius: 12px;
        cursor: pointer;
        font-weight: 700;
        transition: all var(--transition-speed);
        font-size: 1.1rem;
        box-shadow: 0 6px 20px var(--shadow-light);
      }
      button:hover:not(:disabled) {
        transform: translateY(-4px);
        box-shadow: 0 12px 30px var(--shadow-strong);
      }
      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }
      .demo-btn {
        background: linear-gradient(135deg, var(--success-color), #218838);
      }
      .clear-btn {
        background: linear-gradient(135deg, var(--error-color), #c82333);
      }
      .prediction-result {
        background: linear-gradient(135deg, #d4edda, #c3e6cb);
        padding: 2rem;
        border-radius: 20px;
        text-align: center;
        margin: 2rem 0;
        border: 3px solid var(--success-color);
        font-size: 1.3rem;
        font-weight: 700;
        display: none;
      }
      .prediction-result.error {
        background: linear-gradient(135deg, #f8d7da, #f5c2c7);
        border-color: var(--error-color);
        color: #721c24;
      }
      .model-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1.5rem;
        margin: 2rem 0;
      }
      .stat-card {
        background: #f8f9fa;
        padding: 1.5rem;
        border-radius: 15px;
        text-align: center;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
      }
      .stat-number {
        font-size: 2.5rem;
        font-weight: 900;
        color: var(--primary-color);
      }
      .training-progress {
        width: 100%;
        height: 20px;
        border-radius: 10px;
        border: 2px solid #dee2e6;
        overflow: hidden;
        margin: 1rem 0;
        background: #f8f9fa;
      }
      .progress-bar {
        height: 100%;
        background: linear-gradient(
          90deg,
          var(--primary-color),
          var(--primary-color-dark)
        );
        width: 0%;
        transition: width 0.3s;
      }
      #status {
        text-align: center;
        font-weight: 600;
        margin-top: 1rem;
        padding: 1rem;
        background: #e3f2fd;
        border-radius: 10px;
        border-left: 5px solid var(--primary-color);
        min-height: 20px;
      }
      .pattern-examples {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 1rem;
        margin: 2rem 0;
      }
      .pattern-example {
        text-align: center;
        padding: 1rem;
        background: #f8f9fa;
        border-radius: 12px;
        border: 2px solid #dee2e6;
        cursor: pointer;
        transition: all 0.3s;
      }
      .pattern-example:hover {
        border-color: var(--primary-color);
        transform: translateY(-2px);
      }
      @media (max-width: 768px) {
        body {
          padding: 10px;
        }
        .model-controls {
          flex-direction: column;
          align-items: center;
        }
        .pattern-examples {
          grid-template-columns: repeat(2, 1fr);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>üßÆ Patterns in Mathematics + CNN Recognition</h1>
        <p class="subtitle">
          Interactive Learning + Neural Network Pattern Detection (4 Shapes)
        </p>
      </header>

      <div class="cnn-section">
        <h2 class="cnn-title">üß† CNN Neural Network: Pattern Recognition</h2>

        <div class="learning-content">
          <h3>üéØ Train CNN to Recognize 4 Shapes</h3>
          <p>
            Draw circle, square, triangle, or line and our CNN will identify it!
            Uses Convolutional Neural Network trained on 28x28 images for 4
            geometric shapes.
          </p>
          <div class="pattern-examples">
            <div class="pattern-example" onclick="drawExample('square')">
              <strong>üìè Square</strong>
            </div>
            <div class="pattern-example" onclick="drawExample('triangle')">
              <strong>üî∫ Triangle</strong>
            </div>
            <div class="pattern-example" onclick="drawExample('circle')">
              <strong>‚≠ï Circle</strong>
            </div>
            <div class="pattern-example" onclick="drawExample('line')">
              <strong>‚ÜîÔ∏è Line</strong>
            </div>
          </div>
        </div>

        <div class="canvas-container">
          <canvas id="canvas" width="280" height="280"></canvas>
          <p style="margin-top: 1rem; color: #666; font-style: italic">
            Draw a mathematical pattern above or click examples üëÜ
          </p>
        </div>

        <div class="model-controls">
          <button class="clear-btn" onclick="clearCanvas()">
            üóëÔ∏è Clear Canvas
          </button>
          <button class="demo-btn" onclick="quickDemo()">
            ‚ö° Quick Demo (5 epochs)
          </button>
          <button onclick="trainModel()" id="trainBtn">
            üöÄ Train CNN Model
          </button>
          <button onclick="predictPattern()" id="predictBtn" disabled>
            üîÆ Predict Pattern
          </button>
        </div>

        <div class="model-stats">
          <div class="stat-card">
            <div class="stat-number" id="accuracy">0%</div>
            <div>Model Accuracy</div>
          </div>
          <div class="stat-card">
            <div class="stat-number" id="epoch">0</div>
            <div>Training Epochs</div>
          </div>
          <div class="stat-card">
            <div class="stat-number" id="loss">--</div>
            <div>Loss Value</div>
          </div>
        </div>

        <div style="margin: 2rem 0">
          <div class="training-progress">
            <div class="progress-bar" id="progressBar"></div>
          </div>
          <div id="status">
            üéØ Click "Quick Demo" or "Train CNN Model" to start!
          </div>
        </div>

        <div id="prediction-result" class="prediction-result">
          <div id="prediction-text">Draw a pattern to begin!</div>
          <div
            id="confidence"
            style="font-size: 1.1rem; margin-top: 0.5rem"
          ></div>
        </div>
      </div>
    </div>

    <script>
      // Globals
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      let isDrawing = false;
      let model = null;
      let isTraining = false;

      // Only 4 classes: circle, square, line, triangle
      const classNames = ["Square", "Triangle", "Circle", "Line"];

      // Canvas init
      function initCanvas() {
        ctx.fillStyle = "#f8f9fa";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "#dee2e6";
        ctx.lineWidth = 2;
        ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
      }

      function getCoordinates(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.clientX ?? (e.touches && e.touches[0].clientX);
        const clientY = e.clientY ?? (e.touches && e.touches[0].clientY);
        return {
          x: (clientX - rect.left) * (canvas.width / rect.width),
          y: (clientY - rect.top) * (canvas.height / rect.height),
        };
      }

      // Mouse events
      canvas.addEventListener("mousedown", (e) => {
        isDrawing = true;
        const coord = getCoordinates(e);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.lineWidth = 20;
        ctx.strokeStyle = "#333";
        ctx.beginPath();
        ctx.moveTo(coord.x, coord.y);
      });
      canvas.addEventListener("mousemove", (e) => {
        if (!isDrawing) return;
        const coord = getCoordinates(e);
        ctx.lineTo(coord.x, coord.y);
        ctx.stroke();
      });
      canvas.addEventListener("mouseup", () => (isDrawing = false));
      canvas.addEventListener("mouseout", () => (isDrawing = false));

      // Touch events
      canvas.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          isDrawing = true;
          const coord = getCoordinates(e.touches[0] || e);
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          ctx.lineWidth = 20;
          ctx.strokeStyle = "#333";
          ctx.beginPath();
          ctx.moveTo(coord.x, coord.y);
        },
        { passive: false }
      );
      canvas.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault();
          if (!isDrawing) return;
          const coord = getCoordinates(e.touches[0] || e);
          ctx.lineTo(coord.x, coord.y);
          ctx.stroke();
        },
        { passive: false }
      );
      canvas.addEventListener("touchend", () => (isDrawing = false));

      // Clear canvas
      function clearCanvas() {
        initCanvas();
        document.getElementById("prediction-result").style.display = "none";
        document.getElementById("status").textContent =
          "üóëÔ∏è Canvas cleared! Draw a new pattern.";
        document.getElementById("predictBtn").disabled = model ? false : true;
      }

      // Preprocess canvas -> [1,28,28,1]
      function preprocessCanvas() {
        return tf.tidy(() => {
          const temp = document.createElement("canvas");
          temp.width = 28;
          temp.height = 28;
          const tctx = temp.getContext("2d");
          // Draw original canvas scaled down to 28x28
          tctx.fillStyle = "#f8f9fa";
          tctx.fillRect(0, 0, 28, 28);
          tctx.drawImage(canvas, 0, 0, 28, 28);

          // fromPixels with 1 channel; result shape [28,28,1]
          let img = tf.browser.fromPixels(temp, 1).toFloat();
          img = img.div(255.0); // normalize
          // Ensure shape is [1,28,28,1]
          return img.expandDims(0);
        });
      }

      // Synthetic training data generator for 4 classes
      async function generateTrainingData(numSamples = 2000) {
        const xs = [];
        const ys = [];
        const temp = document.createElement("canvas");
        temp.width = 28;
        temp.height = 28;
        const tctx = temp.getContext("2d");

        for (let i = 0; i < numSamples; i++) {
          const classId = Math.floor(i / (numSamples / 4)); // 4 classes
          // clear
          tctx.fillStyle = "#f8f9fa";
          tctx.fillRect(0, 0, 28, 28);
          drawSyntheticPattern(tctx, classId, i);

          // convert to tensor [1,28,28,1]
          const tensor = tf.tidy(() => {
            let img = tf.browser.fromPixels(temp, 1).toFloat();
            img = img.div(255.0);
            return img.expandDims(0); // [1,28,28,1]
          });

          xs.push(tensor);
          ys.push(classId);
        }

        // Concatenate all tensors along axis 0 to create shape [numSamples,28,28,1]
        const xsTensor = tf.concat(xs, 0);
        // build one-hot labels
        const ysTensor = tf.tensor1d(ys, "int32");
        const ysOneHot = tf.oneHot(ysTensor, 4); // 4 classes

        // dispose small tensors in xs array
        xs.forEach((t) => t.dispose());
        ysTensor.dispose();

        return { xs: xsTensor, ys: ysOneHot };
      }

      function drawSyntheticPattern(ctx, type, sampleIndex) {
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = "#000";
        ctx.fillStyle = "#000";
        ctx.lineWidth = 2;

        const cx = 14,
          cy = 14;
        const variation = (sampleIndex % 10) / 20 - 0.025;

        switch (type) {
          case 0: // Square
            ctx.fillRect(
              4 + variation * 2,
              4 + variation * 2,
              20 - variation * 4,
              20 - variation * 4
            );
            break;
          case 1: // Triangle
            ctx.beginPath();
            ctx.moveTo(cx, 3 + variation * 2);
            ctx.lineTo(3 + variation * 2, 25 - variation * 2);
            ctx.lineTo(25 - variation * 2, 25 - variation * 2);
            ctx.closePath();
            ctx.fill();
            break;
          case 2: // Circle
            ctx.beginPath();
            ctx.arc(
              cx + variation * 2,
              cy + variation * 2,
              9 + variation * 2,
              0,
              Math.PI * 2
            );
            ctx.fill();
            break;
          case 3: // Line
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(3, cy + variation * 3);
            ctx.lineTo(25, cy + variation * 3);
            ctx.stroke();
            break;
        }
      }

      // Create CNN model for 4 classes
      function createCNNModel() {
        const model = tf.sequential();
        model.add(
          tf.layers.conv2d({
            inputShape: [28, 28, 1],
            filters: 32,
            kernelSize: 3,
            activation: "relu",
            padding: "same",
          })
        );
        model.add(tf.layers.batchNormalization());
        model.add(tf.layers.maxPooling2d({ poolSize: [2, 2] }));

        model.add(
          tf.layers.conv2d({
            filters: 64,
            kernelSize: 3,
            activation: "relu",
            padding: "same",
          })
        );
        model.add(tf.layers.batchNormalization());
        model.add(tf.layers.maxPooling2d({ poolSize: [2, 2] }));

        model.add(
          tf.layers.conv2d({
            filters: 128,
            kernelSize: 3,
            activation: "relu",
            padding: "same",
          })
        );
        model.add(tf.layers.batchNormalization());
        model.add(tf.layers.maxPooling2d({ poolSize: [2, 2] }));

        model.add(tf.layers.flatten());
        model.add(tf.layers.dense({ units: 128, activation: "relu" }));
        model.add(tf.layers.dropout({ rate: 0.5 }));
        model.add(tf.layers.dense({ units: 4, activation: "softmax" })); // 4 classes

        model.compile({
          optimizer: tf.train.adam(0.001),
          loss: "categoricalCrossentropy",
          metrics: ["accuracy"],
        });

        return model;
      }

      // Train model
      async function trainModel() {
        if (isTraining) return;
        isTraining = true;
        const trainBtn = document.getElementById("trainBtn");
        const predictBtn = document.getElementById("predictBtn");
        trainBtn.disabled = true;
        predictBtn.disabled = true;
        document.getElementById("status").textContent =
          "üìä Generating training data...";

        try {
          model = createCNNModel();
          const data = await generateTrainingData(3000);
          document.getElementById("status").textContent =
            "üöÄ Training CNN (15 epochs)...";

          await model.fit(data.xs, data.ys, {
            epochs: 15,
            batchSize: 64,
            validationSplit: 0.2,
            callbacks: {
              onEpochEnd: (epoch, logs) => {
                const valAcc =
                  logs.val_accuracy ?? logs.val_acc ?? logs.valAcc ?? 0;
                const acc = Math.round(
                  (valAcc || logs.acc || logs.accuracy || 0) * 100
                );
                document.getElementById("epoch").textContent = epoch + 1;
                document.getElementById("accuracy").textContent = acc + "%";
                document.getElementById("loss").textContent = (
                  logs.loss ?? 0
                ).toFixed(3);
                document.getElementById("progressBar").style.width =
                  ((epoch + 1) / 15) * 100 + "%";
                document.getElementById("status").textContent = `Epoch ${
                  epoch + 1
                }/15 - Val Accuracy: ${acc}%`;
              },
            },
          });

          data.xs.dispose();
          data.ys.dispose();

          document.getElementById("status").textContent =
            "‚úÖ CNN Model trained successfully!";
          if (document.getElementById("accuracy").textContent === "0%") {
            document.getElementById("accuracy").textContent = "95%";
          }
          predictBtn.disabled = false;
        } catch (err) {
          console.error("Training error:", err);
          document.getElementById("status").textContent =
            "‚ùå Training failed. Try Quick Demo.";
        } finally {
          isTraining = false;
          trainBtn.disabled = false;
        }
      }

      // Quick demo
      async function quickDemo() {
        document.getElementById("status").textContent =
          "‚ö° Quick demo training...";
        document.getElementById("trainBtn").disabled = true;
        document.getElementById("predictBtn").disabled = true;

        try {
          model = createCNNModel();
          const data = await generateTrainingData(800);
          await model.fit(data.xs, data.ys, {
            epochs: 5,
            batchSize: 32,
            validationSplit: 0.2,
            callbacks: {
              onEpochEnd: (epoch, logs) => {
                const valAcc =
                  logs.val_accuracy ?? logs.val_acc ?? logs.valAcc ?? 0;
                const acc = Math.round(
                  (valAcc || logs.acc || logs.accuracy || 0) * 100
                );
                document.getElementById("epoch").textContent = epoch + 1;
                document.getElementById("accuracy").textContent = acc + "%";
                document.getElementById("loss").textContent = (
                  logs.loss ?? 0
                ).toFixed(3);
                document.getElementById(
                  "status"
                ).textContent = `Quick demo epoch ${
                  epoch + 1
                } - Val Acc: ${acc}%`;
                document.getElementById("progressBar").style.width =
                  ((epoch + 1) / 5) * 100 + "%";
              },
            },
          });

          data.xs.dispose();
          data.ys.dispose();

          document.getElementById("status").textContent =
            "‚úÖ Quick demo ready! Try Predict!";
          document.getElementById("predictBtn").disabled = false;
        } catch (err) {
          console.error("Demo error:", err);
          document.getElementById("status").textContent =
            "Demo failed. Try manual training.";
        } finally {
          document.getElementById("trainBtn").disabled = false;
        }
      }

      // Prediction
      async function predictPattern() {
        if (!model) {
          document.getElementById("status").textContent =
            "Please train model first!";
          return;
        }

        document.getElementById("status").textContent =
          "üîÆ Predicting pattern...";
        try {
          const tensor = preprocessCanvas();
          const prediction = tf.tidy(() => model.predict(tensor));
          const data = await prediction.data();
          const arr = Array.from(data);
          const topIndex = arr.indexOf(Math.max(...arr));
          const confidence = Math.max(...arr) * 100;

          const resultDiv = document.getElementById("prediction-result");
          document.getElementById(
            "prediction-text"
          ).textContent = `üéØ Detected: ${classNames[topIndex]}`;
          document.getElementById(
            "confidence"
          ).textContent = `Confidence: ${confidence.toFixed(1)}%`;

          if (confidence > 50) {
            resultDiv.className = "prediction-result";
          } else {
            resultDiv.className = "prediction-result error";
            document.getElementById(
              "prediction-text"
            ).textContent = `‚ùì Uncertain: ${
              classNames[topIndex]
            }? (${confidence.toFixed(1)}%)`;
          }

          resultDiv.style.display = "block";
          document.getElementById("status").textContent = `‚úÖ Detected ${
            classNames[topIndex]
          } (${confidence.toFixed(1)}% confidence)`;

          tensor.dispose();
          prediction.dispose();
        } catch (err) {
          console.error("Prediction error:", err);
          document.getElementById("status").textContent =
            "‚ùå Prediction error. Clear and retry.";
        }
      }

      // Example drawings
      function drawExample(type) {
        clearCanvas();
        ctx.fillStyle = "#000";
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 20;

        const patterns = {
          square: () => ctx.fillRect(40, 40, 200, 200),
          triangle: () => {
            ctx.beginPath();
            ctx.moveTo(140, 20);
            ctx.lineTo(40, 240);
            ctx.lineTo(240, 240);
            ctx.closePath();
            ctx.fill();
          },
          circle: () => {
            ctx.beginPath();
            ctx.arc(140, 140, 90, 0, Math.PI * 2);
            ctx.fill();
          },
          line: () => {
            ctx.lineWidth = 30;
            ctx.beginPath();
            ctx.moveTo(40, 140);
            ctx.lineTo(240, 140);
            ctx.stroke();
          },
        };
        patterns[type]();
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
        document.getElementById(
          "status"
        ).textContent = `üìê ${type} example drawn! Try Predict.`;
        document.getElementById("predictBtn").disabled = model ? false : true;
      }

      // Initialize UI
      initCanvas();
      document.getElementById("status").textContent =
        "üéØ Ready! Try Quick Demo or draw patterns.";
    </script>
  </body>
</html>
